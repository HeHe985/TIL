# SW 문제해결 응용 - 탐욕 알고리즘
# 조합적 문제
## 부분 집합
- powerset
- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분
- 딥합에 포함된 원소들을 선택하는 것
### 구현 방법
1. 완전 탐색
   - 재귀호츌을 이용한 완전탐색
   - 실전보다는 완전 탐색 학습용으로 추천
```python
name = ['MIN', 'CO', 'TIM']


def recur(cnt, subset):
    if cnt == 3:
        print(*subset)
        return

    # 부분집합에 포함 시키는 경우
    recur(cnt + 1, subset + [name[cnt]])
    # 포함 시키지 않는 경우
    recur(cnt + 1, subset)


recur(0, [])
```
2. Binaty Counting
   - 2진수 & 비트연산을 이용
   - 모든 부분 집합이 필요할 때 사용
   - 원소 수에 해당하는 N개의 비트열을 이용해 부분집합 표시
```python
# Binary Counting으로 부분집합 생성
arr = ['A', 'B', 'C']
n = len((arr))


def get_subset(target):
    for i in range(n):
      # 가장 우측 비트를 체크(1이가만 하면 됨, 0b1, True, 1, 0b00001 다 된다)
      # 왜 '0x1'??: 비트연산임을 명시하는 암묵적인 룰
        if target & 0x1:
            print(arr[i], end=' ')
        target >>= 1


for tar in range(1 << n):
    get_subset(tar)
    print()
```
## 조합
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
```python
arr = ['A', 'B', 'C', 'D', 'E']
N = 3

path = []

def recur(cnt, start):
    if cnt == N:
        print(*path)
        return

    for i in range(start, len(arr)):
        path.append(arr[i])
        recur(cnt + 1, i + 1)
        # recut(cnt + 1, i) -> 중복을 허용하는 조합
        path.pop()
recur(0, 0)
```
# 탐욕 알고리즘
## Greedy
- 결정이 필요할 때, 현재 기준으로 가장 좋아보이는 선택지로 결정하여 답을 도출하는 알고리즘
- 그리디로 풀 수 있는가?
  1. 탐욕적 선택 조건(Greedy Choice Property)
     - 각 단계의 최적해 선택이 이 후 단계 선택에 영향을 주지 않음
     - 즉, 각 단계 규칙이 변경되면 안됨
     - 동전 문제 예시:
       - 첫번째 단계: 가장 큰 동전(500)이 가능한 만큼
       - 두번째 단계: 가장 큰 동전(100)이 가능한 만큼
  2. 최적 부분 구조(Optimal Substructure)
     - 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이 되어야 함
       - 증명을 통해 해결
     - 동전 문제 예시
     - [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나옴
     - [간접 증명]
       - 최적해보다 더 적은 동전으로표현 가능(가정)
       - N원을 더 작은 값의 동전으로 저 작은 수로 할 수 있다.
         - 동전이 배수로 있기 때문에 불가능
         - 더 적은 값으로 나누면 무조건 더 큰 수가 나옴
       - 모순 발생
         - 원래 명제가 참
  3. 
## knapsack 문제
## 활동 선택 문제
## 연