# SW 문제해결 기본 - Stack 2
## 부분집합
### 각 원소가 부분집합에 포함되었는지 loop를 이용하여 확인하고 부분집합을 생성하는 방법
```python
bit = [0, 0, 0, 0]
for i in range(2):
  bit[0] = i                # 0번째 원소
  for j in range(2):
    bit[1] = j              # 1번째 원소
    for k in range(2):
      bit[2] = k            # 2번째 원소
      for l in range(2):
        bit[3] = l          # 3번째 원소
        print(bit)          # 생성된 부분집합 출력
```
### Powerset을 구하는 Backtracking 알고리즘 1
```python
def backtrack(a, k, n):       # a: 주어진 배열, k: 결정할 원소, n: 원소 개수
  c = [0] * MAXCANDIDATES     # c: 후보군을 저장할 배열, MAXCANDIDATES:최대 후보군 수

  if k == n:
  process_solution(a, k)
  else:
    ncandidates = construct_candidates(a, k, n, c)    # 후보 추천 함수
    for i in range(ncandidates):                      # ncandidates: 후보 수
      a[k] = c[i]
      backtrack(a, k + 1, n)
```
## 순열1
### 단순한 순열 생성 방법
```python
for i1 in range(1, 4):
  for i2 in range(1, 4):
    if i2 != i1:
      for i3 in range(1, 4):
        if i3 != i1 and i3 != i2:
          print(i1, i2, i3)
```
## 가지치기
- 각 단계(원소)에 대해 포함/불포함을 확인
### 부분집합의 합
- i원소의 포함 여부를 결정하면 i까지의 부분집합의 합 Si를 결정할 수 있음
- Si-1이 찾고자하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음
### A[i] 원소를 부분집합의 원소로 고려하는 재귀함수(A는 서로 다른 자연수의 집합)
```python
def f(i, k, s, t):  # i원소, k 집합의 크기, s i-1까지 고려된 합, t목표
    global cnt
    global fcnt
    fcnt += 1
    if s > t:   # 고려한 원소의 합이 찾는 합보다 큰경우
        return
    elif s == t:    # 남은 원소를 고려할 필요가 없는 경우
        cnt += 1
        return
    elif i == k:    # 모든원소 고려
        return
    else:
        bit[i] = 1
        f(i+1, k, s+A[i], t)    # A[i] 포함
        bit[i] = 0
        f(i+1, k, s, t)         # A[i] 미포함

#A = [1,2,3,4,5,6,7,8,9,10]
N = 10
A = [ i for i in range(1, N+1)]

key = 55
cnt = 0
bit = [0]*N
fcnt = 0
f(0,N,0,key)
print(cnt, fcnt)      # 합이 key인 부분집합의 수
```
## 순열2
### 자리 교환으로 순열 생성
```python
def f(i, N):    # 크기가 N이고 순열을 저장한 p배열에서 p[i]를 결정하는 함수
    if i == N:  #
        print(p)
    else:
        for j in range(i, N):
            p[i], p[j] = p[j], p[i]
            f(i+1, N)   # i+1자리 결정
            p[i], p[j] = p[j], p[i]

p = [0,1,2]
N = 3
f(0, N)

```
## 분할정복