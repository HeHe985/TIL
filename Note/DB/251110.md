# Database - Many To Many Relationsips 01
# Many to many relationsips
- 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
## N:1의한계
### 의사와 환자 간 모델 관계 설정
- 한명의 의사에게 여러 환자가 예약할 수 있도록 models 클래스 정의
  - Patient 모델에 Doctor 모델을 참조하도록 정의
- Migration까지 적용하여 데이터베이스에 적용
```python
# hospitals/models.py
class Doctor(models.Model):
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'


class Patient(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
```
### 의사와 환자 데이터 생성
- Django shell을 활용하여 2명의 의사를 생성
```cmd
$ python manage.py shell

In [1]: doctor1 = Doctor.objects.create(name='allie')

In [2]: doctor2 = Doctor.objects.create(name='barbie')

In [3]: doctor1
Out[3]: <Doctor: 1번 의사 allie>

In [4]: doctor2
Out[4]: <Doctor: 2번 의사 barbie>
```
- Django shell을 활용하여 2명의 의사를 생성하고 환자는 서로 다른 의사에게 예약
```cmd
In [5]: patient1 = Patient.objects.create(name='carol', doctor=doctor1)

In [6]: patient2 = Patient.objects.create(name='duke', doctor=doctor2)

In [7]: patient1
Out[7]: <Patient: 1번 환자 carol>

In [8]: patient2
Out[8]: <Patient: 2번 환자 duke>
```
### N:1의 한계 상황
- 1번 환자가 두 의사 모두에게 진료를 받고자 한다면 환자 테이블에 1번 환자 데이터가 중복으로 입력될 수 밖에 없음
```cmd
In [9]: patient3 = Patient.objects.create(name='carol', doctor=doctor2)

In [10]: patient3
Out[10]: <Patient: 3번 환자 carol>
```
- 환자가 진료받을 의사 정보를 동시에 저장을 시도했을 때는 에러가 발생함
```cmd
In [11]: patient4 = Patient.objects.create(name='duke', doctor=doctor1, doctor2)
  Cell In[11], line 1
    patient4 = Patient.objects.create(name='duke', doctor=doctor1, doctor2)
                                                                          ^
SyntaxError: positional argument follows keyword argument
```
- 동일한 환자지만 다른 의사에게도 진료받기 위해 새로운 예약 데이터를 만들어야 하며 이 때, 동일한 환자 정보를 또 작성하여 저장됨
  - 데이터의 중복이 발생하면 나중에 환자의 정보가 바뀌었을 때, 모든 예약 정보를 하나하나 찾아서 고쳐야하는 문제가 발생하고, 실수로 하나라도 누락한다면 데이터의 일관성이 깨지게 됨
- 외래키 컬럼에 '1, 2' 형태로 저장하는 것은 DB 타입 문제로 불가능
  - 제 1정규형을 만족하지 못하기 때문에 사용이 불가
    - 제 1정규형: 테이블의 모든 칸에 더 이상 쪼갤 수 없는 하나의 값만 넣어야 함
- 의사의 정보도 외래키로 참조하고, 환자의 정보도 외래키로 참조하는 별개의 테이블을 생성
  - 예약 테이블로 분리
## 중개 모델
- 다대다 관계에서 두 모델을 연결하는 역할을 하는, 특별한 기능을 가진 모델
- 중개 모델을 사용하면 Doctor 모델이나 Patient 모델에 없는, 예약 행위 자체에 대한 상세한 정보를 담을 수 있어 복잡한 현실 세계의 관계를 더욱 정교하게 표현할 수 있음
### 예약 모델 생성
- 환자 모델의 외래키를 삭제하고 별도의 예약 모델을 새로 생성
- 예약 모델은 의사와 환자에 각각 N:1의 관계를 가짐
```python
# hospitals/models.py
# 외래키 삭제


# 중개모델 작성

```
### 예약 데이터 생성
- 데이터베이스 초기화 후 Migration 진행 및 shell 실행
- 의사와 환자 데이터 생성 후 예약 정보 추가하기
```cmd
In [1]: doctor1 = Doctor.objects.create(name='allie')

In [2]: patient1 = Patient.objects.create(name='carol')

In [3]: Reservation.objects.create(doctor=doctor1, patient=patient1)
Out[3]: <Reservation: 1번 의사의 1번 환자>

In [4]: doctor1
Out[4]: <Doctor: 1번 의사 allie>

In [5]: patient1
Out[5]: <Patient: 1번 환자 carol>

In [6]: reservation1 = Reservation.objects.create(doctor=doctor1, patient=patient1)

In [7]: reservation1
Out[7]: <Reservation: 1번 의사의 1번 환자>
```
### 예약 정보 조회
- 의사와 환자가 예약 모델을 통해 각각 본인의 진료 내역 확인
  - 각각의 의사 혹은 환자 데이터에서 중개 테이블의 역참조를 통해 예약 내역을 확인할 수 있음
```cmd
# 의사 -> 예약 정보 찾기
In [10]: doctor1.reservation_set.all()
Out[10]: <QuerySet [<Reservation: 1번 의사의 1번 환자>, <Reservation: 1번 의사의 1번 환자>]>

# 환자 -> 예약 정보 찾기
In [11]: patient1.reservation_set.all()
Out[11]: <QuerySet [<Reservation: 1번 의사의 1번 환자>, <Reservation: 1번 의사의 1번 환자>]>
```
### 추가 예약 생성
- 1번 의사에게 새로운 환자 예약 생성
```cmd
In [12]: patient2 = Patient.objects.create(name='duke')

In [13]: reservation2 = Reservation.objects.create(doctor=doctor1, patient=patient2)

In [14]: patient2
Out[14]: <Patient: 2번 환자 duke>

In [15]: reservation2
Out[15]: <Reservation: 1번 의사의 2번 환자>
```
### 예약 정보 조회
- 1번 의사의 전체 예약 정보 조회
  - 예약 테이블의 역참조를 활용해서 어떤 예약이 있는지 확인할 수 있음
```cmd
# 의사 -> 환자 목록
In [16]: doctor1.reservation_set.all()
Out[16]: <QuerySet [<Reservation: 1번 의사의 1번 환자>, <Reservation: 1번 의사의 1번 환자>, <Reservation: 1번 의사의 2번 환자>]>
```
- 이렇게 다대다 관계의 경우 중개 테이블을 생성해서 데이터를 효율적으로 관리할 수 있음
- Django에서는 ManyToManyField를 통해 두 모델 간의 중간 테이블(중개 모델)이 자동으로 만들어짐
## ManyToManyField
- M:N 관계 설정 모델 필드
- 이 필드를 설정하면 Django는 자동으로 중개 모델을 생성하여 각 모델 간의 관계를 관리
- 모델 클래스 내부에 필드로 정의하며, 어느 모델에 정의해도 관계는 동일하게 유지
- ManyToManyField의 필드명은 다대다 관계를 나타내기 위해 복수형으로 작성 권장
- ManyToManyField의 필수 인자는 관계를 가지는 모델 클래스를 작성
### ManyToManyField 조작
- .add() 메서드
  - 중개 테이블에 새로운 데이터를 추가할 때 사용
  - 인자로 연결할 대상 모델의 인스턴스를 넣어서 사용
```cmd
# 단일 인스턴스 추가
patient.doctors.add(doctor1)

# 여러 인스턴스 한 번에 추가
patient.doctors.add(doctor2, doctor3)
```
- .remove() 메서드
  - 중개 테이블에 있는 데이터를 삭제할 때 사용
  - 인자로 전달한 인스턴스를 중개 테이블에서 제거하며, 대상 객체 자체는 삭제 되지 않음
```cmd
# 단일 관계 삭제
patient.doctors.remove(doctor1)

# 여러 관계 한 번에 삭제
patient.doctors.remove(doctor2, doctor3)
```
### Django ManyToManyField 실습
- 환자 모델에 ManyToManyField 작성
  - 의사 모델에 작성해도 상관없으며 참조/역참조 관계만 기억할 것
  - 환자 모델은 의사 모델을 참조, 의사 모델은 환자 모델을 역참조
```python
# hospitals/models.py

class Patient(models.Model):
    # ManyToManyField 작성
    doctors = models.ManyToManyField(Doctor, through='Reservation')
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
# Reservation Class 주석 처리
```
- 데이터베이스 초기화 후 Migration 진행 및 shell 실행
- 생성된 중개 테이블 hospitals_patient_doctors 확인
  - 중개 테이블 이름은 '앱이름_모델클래스명_필드명'으로 생성됨
- 의사 1명과 환자 2명에 대한 데이터 생성
```cmd
In [1]: doctor1 = Doctor.objects.create(name='allie')

In [2]: patient1 = Patient.objects.create(name='carol')

In [3]: patient2 = Patient.objects.create(name='duke')
```
- 환자1의 예약에 의사1을 추가하고 예약 내역 조회하기
  - 환자의 경우 클래스 내부에 필드를 가지고 있어 참조로 조회
  - 의사의 경우 역참조를 통해 환자 데이터 조회
```cmd
In [4]: patient1.doctors.add(doctor1)

In [5]: patient1.doctors.all()
Out[5]: <QuerySet [<Doctor: 1번 의사 allie>]>

In [6]: doctor1.patient_set.all()
Out[6]: <QuerySet [<Patient: 1번 환자 carol>]>
```
- 의사1이 환자2에 대한 예약 추가하고 예약 내역 조회
  - 의사는 역참조 매니저를 통해 환자를 추가할 수 있음
```cmd
In [7]: doctor1.patient_set.add(patient2)

In [8]: doctor1.patient_set.all()
Out[8]: <QuerySet [<Patient: 1번 환자 carol>, <Patient: 2번 환자 duke>]>

In [9]: patient2.doctors.all()
Out[9]: <QuerySet [<Doctor: 1번 의사 allie>]>

In [10]: patient1.doctors.all()
Out[10]: <QuerySet [<Doctor: 1번 의사 allie>]>
```
- 중개 테이블에서 예약 현황 확인
  - 환자와 의사 정보가 외래키로 저장되어 있음
  - 데이터의 중복없이 정보를 효율적으로 저장
- 예약 취소(삭제)
- 이전에는 Reservation을 찾아서 지워야 했다면, 이제는 .remove()로 삭제 가능
```cmd
In [11]: doctor1.patient_set.remove(patient1)

In [12]: doctor1.patient_set.all()
Out[12]: <QuerySet [<Patient: 2번 환자 duke>]>

In [13]: patient1.doctors.all()
Out[13]: <QuerySet []>

In [15]: patient2.doctors.remove(doctor1)

In [16]: patient2.doctors.all()
Out[16]: <QuerySet []>

In [17]: doctor1.patient_set.all()
Out[17]: <QuerySet []>
```
### 기본 ManyToManyField의 한계
- 기본 ManyToManyField로 생성된 예약 중개 테이블은 의사와 환자의 외래키 정보만 저장하고 있음
- 만약 예약 중개 테입블에 병의 증상, 예약 일정, 방문 횟수에 대한 추가 정보가 필요한 경우, 기본 ManyToManyField를 그대로 사용할 수 없음
- 추가 정보를 저장하기 위해서는 사용자가 직접 중개 테이블을 정의해야 함
  - 사용자가 직접 중개 테이블을 정의하면 .add(), .remove() 메서드를 사용할 수 없음
- ManyToManyField에 'through' 속성을 통해 사용자가 작성한 중개 테이블을 등록하면 추가 정보 저장 및 .add(), .remove() 메서즈를 그대로 활용할 수 있게 됨
## 'through' argument
- 중개 테이블에 추가 데이터를 사용해 M:N 관계를 형성하려는 경우에 사용
### 'through' 속성 실습
- Reservation Class 재작성 및 through 설정
  - 이제는 예약 정보에 증상과 예약일이라는 추가 필드가 생김
```python
class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor, through='Reservation')
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'


class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    symptom = models.TextField()
    reserved_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'{self.doctor.pk}번 의사의 {self.patient.pk}번 환자'
```
- 데이터베이스 초기화 후 Migration 진행 및 shell 실행
- 의사 1명과 환자 2명 생성
```cmd
In [1]: doctor1 = Doctor.objects.create(name='allie')

In [2]: patient1 = Patient.objects.create(name='carol')

In [3]: patient2 = Patient.objects.create(name='duke')
```
- 예약 생성 방법 - 1
  - Reservation class를 통한 예약 생성
```cmd
In [4]: reservation1 = Reservation(doctor=doctor1, patient=patient1, symptom='headache')

In [5]: reservation1.save()

In [6]: doctor1.patient_set.all()
Out[6]: <QuerySet [<Patient: 1번 환자 carol>]>

In [7]: patient1.doctors.all()
Out[7]: <QuerySet [<Doctor: 1번 의사 allie>]>
```
- 예약 생성 방법 - 2
  - Patient 또는 Doctor의 인스턴스를 통한 예약 생성(Through_defaults)
  - .add() 메서드의 through_defaults 인자에 {필드명: 값} 형태로 전달하면 중개 모델의 해당 필드에 값이 저장됨
```cmd
In [8]: patient2.doctors.add(doctor1, through_defaults={'symptom': 'flu'})

In [9]: doctor1.patient_set.all()
Out[9]: <QuerySet [<Patient: 1번 환자 carol>, <Patient: 2번 환자 duke>]>

In [10]: patient2.doctors.all()
Out[10]: <QuerySet [<Doctor: 1번 의사 allie>]>
```
- 중개 테이블에 생성된 예약 정보 확인
  - 두 방법 모두 중개 테이블에 잘 저장되었음을 확인
- 생성과 마찬가지로 의사와 환자 모두 각각 예약 삭제 가능
```cmd
# 직접 중개 테이블의 인스턴스를 활용한 삭제
In [11]: reservation1.delete()
Out[11]: (1, {'hospitals.Reservation': 1})

# 의사 데이터를 통해 환자와의 예약 삭제
In [12]: doctor1.patient_set.remove(patient2)
```
### M:N 관계 주요 사항 정리
- M:N 관계로 맺어진 두 테이블에는 물리적인 변화가 없음
- ManyToManyField는 중개 테이블을 자동으로 생성
- ManyToManyField는 M:N 관계를 맺는 두 모델 어디에 위치해도 상관 없음
  - 대신 필드 작성 위치에 따라 참조와 역참조 방향을 주의할 것
- N:1은 완전한 종속의 관계였지만 M:N은 종속적인 관계가 아니며 '의사에게 진찰받는 환자' & '환자를 진찰하는 의사' 이 두 형태 모두 표현 가능
# ManyToManyField
## ManyToManyField 특징
- ManyToManyField(to, **options)
  - M:N 관계 설정 시 사용하는 모델 필드
  - 어느 모델에서든 관련 객체에 접근할 수 있는 양방향 관계
  - 동일한 관계는 한 번만 저장되며 중복되지 않음
## ManyToManyField의 대표인자 3가지
1. related_name
   - 역참조 이름을 변경할 때 설정하는 인자
2. symmetrical
   - 관계 설정 시 대칭에 대한 설정을 하는 인자
3. through
   - 직접 생성한 중개 테이블을 등록하는 인자
### 'related_name' argument
- 역참조시 사용하는 manager name을 변경
  - 기본값인 '역참조모델명_set'을 다른 이름으로 변경할 때 사용
  - 이름을 변경하면 더 이상 기본값을 사용할 수 없음
```python
class Patient(models.Model):
    # ManyToManyField - related_name 작성
    doctors = models.ManyToManyField(Doctor, related_name='patients')
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
```
```cmd
# 변경 전
doctor.patient_set.all()

# 변경 후(이전 manager name은 사용 불가)
doctor.patient.all()
```
### 'symmetrical' argument
- 관계 설정 시 대칭 유무 설정
- ManyToManyField가 동일한 모델을 가리키는 정의에서만 사용
- 기본값: True
```python
class Person(models.Model):
  friends = models.ManytoManyField('self')
  # friends = models.ManyToManyField('self', symmetrical=False)
```
- source 모델: 관계를 시작하는 모델
- target: 관계의 대상이 되는 모델
- symmetrical 값이 True인 경우
  - source 모델의 인스턴스가 target 모델의 인스턴스를 참조하면 자동으로 target 모델 인스턴스도 source 모델 인스턴스를 자동으로 참조하도록 함(대칭)
  - 즉, 내가 당신의 친구라면 자동으로 당신도 내 친구가 됨
- symmetrigal 값이 False인 경우
  - True와 반대(비대칭)
### 'through' argument
- 사용하고자 하는 중개 모델을 지정
- 일반적으로 추가 데이터를 M:N 관계와 연결하려는 경우에 활용
```python
class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor, through='Reservation')
    name = models.TextField()


class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    symptom = models.TextField()
    reserved_at = models.DateTimeField(auto_now_add=True)
```
# 좋아요 기능 구현
## 모델 관계 설정
### 다대다 관계 설정
- Many to Many relationships
  - 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
  - 양쪽 모두에서 N:1 관계를 가짐
### 좋아요 기능의 모델 관계 설정
- Article(M) - User(N)
  - 게시글은 좋아요가 없을 수도 있고, 여러개 존재할 수 있음
  - 사용잗 게시글에 좋아요를 한 번도 누르지 않았을 수도 있고, 여러개의 게시글에 좋아요를 누를 수 있음
- Article 클래스에 ManyToManyField 작성
  - 필드명은 직관적이고 복수형으로 작성
```python
# article/models.py

class Article(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    like_users = models.ManyToManyField(settings.AUTH_USER_MODEL)
    title = models.CharField(max_length=10)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```
- Migration 진행 시 에러 발생 확인
  - 유저가 게시글을 역참조 할 때 역참조 이름에 대한 충돌이 발생하고 있음
```cmd
$ python manage.py makemigrations
SystemCheckError: System check identified some issues:

ERRORS:
articles.Article.like_users: (fields.E304) Reverse accessor 'User.article_set' for 'articles.Article.like_users' clashes with reverse accessor for 'articles.Article.user'.
        HINT: Add or change a related_name argument to the definition for 'articles.Article.like_users' or 'articles.Article.user'.
articles.Article.user: (fields.E304) Reverse accessor 'User.article_set' for 'articles.Article.user' clashes with reverse accessor for 'articles.Article.like_users'.
        HINT: Add or change a related_name argument to the definition for 'articles.Article.user' or 'articles.Article.like_users'.
```
### 역참조 매니저 충돌
- 게시글의 작성자 저장을 위해 설정한 ForeignKey의 역참조
  - '유저가 작성한 게시글'을 확인하기 위해서는 'article_set'을 사용해야 함
  - user.article_set.all()
- 좋아요 기능을 위해 설정한 ManyToManyField의 역참조
  - '유저가 좋아요 한 게시글'을 확인하기 위해서는 'article_set'을 사용해야 함
  - user.article_set.all()
- 'article_set'의 역참조 이름이 겹치게 되어 충돌이 발생하고 있음
- User와 Article 모델 사이에 ForeignKey(작성자)와 ManyToManyField(좋아요) 두 관계가 공존하면서 'article_set'이라는 역참조 이름이 충돌하여 어떤 데이터에 접근해야 하는지 알 수 없게 됨
- 'user가 작성한 글(user.article_set)'과 'user가 좋아요 누른 글(user.article_set)'을 구분할 수 있도록 코드 수정 필요
- 두 관계 중 하나에 related_name을 설정해야 하는데, 일반적으로 ManyToManyField 쪽에 related_name을 추가하는 것을 권장
### M:N 관계를 바꾸는 것이 더 좋은 이유 2가지
1. 소유 관계의 기본값 유지
   - ForeignKey(1:N) 관계는 보통 소유나 소속의 의미를 가짐
   - Django의 기본 역참조 이름이 'article_set'은 'User가 소유한 Article의 집합'이라는 매우 직관적인 의미로 해석됨
   - 이처럼 가장 중요하고 대표적인 관계의 기본값을 그대로 유지하는 것이 코드의 예측 가능성을 높임
2. 행위 관계의 명시적 표현
   - ManyToManyField(M:N) 관계는 보통 참여나 행위의 의미를 가짐
   - 이 관계에 related_name='like_articles' 처럼 행위의 의미가 드러나는 구체적인 이름을 붙여주면, 코드의 가독성이 크게 향상됨
### 충돌 해결하기
- user.article_set.all()
  - 이 유저가 작성한 모든 글(소유 관계, 기본)
- user.like_articles.all()
  - 이 유저가 좋아요를 누른 모든 글(행위 관계, 명시적)
- 핵심적인 소유 관계(N:1)는 기본값을 유지하고, 부가적인 행위 관계(M:N)에 구체적인 이름을 붙여주는 것으로 설계
- related_name 작성 후 Migration 재진행
```python
# articles/models.py
class Article(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_articles')
    title = models.CharField(max_length=10)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```
- 생성된 중개 테이블 확인
### User - Article 간 사용 가능한 전체 related manager
- article.user
  - 게시글을 작성한 유저 - N:1
- user.article_set
  - 유저가 작성한 게시글(역참조) - N:1
- article.like_users
  - 게시글을 좋아요 한 유저 - M:N
- user.like_articles
  - 유저가 좋아요 한 게시글(역참조) - M:N
## 기능 구현
### 좋아요 기능 구현
- 좋아요 기능을 담당할 URL 등록
- 어떤 게시글에 좋아요가 눌렸는지 정보를 전달하기 위해 '게시글 pk' 정보를 variable routing으로 추가
```python
# articles/urls.py
app_name = 'articles'
urlpatterns = [
    ...
    # 좋아요 URL
    path('<int:article_pk>/likes/', views.likes, name='likes'),
]
```
- view 함수 구현
  - 사용자가 게시글의 좋아요 목록에 있으면 좋아요 취소
  - 사용자가 게시글의 좋아요 목록에 없으면 좋아요 추가
```python
# articles/views.py

@login_required
def likes(request, article_pk):
    article = Article.objects.get(pk=article_pk)
    if request.user in article.like_users.all():
        article.like_users.remove(request.user)
        # request.user.like_article.remove(article)
    else:
        article.like_users.add(request.user)
        # request.user.like_article.add(article)
    return redirect('articles:index')
```
- index 템플릿에서 각 게시글에 좋아요 버튼 출력
  - 좋아요 버튼의 value도 현재 상태에 따라 다르게 출력하도록 코드 작성
```html
<!-- articles/index.html -->
{% for article in articles %}
  <div>
    <p>작성자 : {{ article.user }}</p>
    {% comment %} <p>작성자 : {{ article.user.username }}</p> {% endcomment %}
    <p>글 번호: {{ article.pk }}</p>
    <p>
      글 제목: <a href="{% url "articles:detail" article.pk %}">{{ article.title }}</a>
    </p>
    <p>글 내용: {{ article.content }}</p>
    <form action="{% url "articles:likes" article.pk %}" method="POST">
      {% csrf_token %}
      {% if request.user in article.like_users.all %}
        <input type="submit" value="좋아요 취소">
      {% else %}
        <input type="submit" value="좋아요">
      {% endif %}
    </form>
  </div>
  <hr>
{% endfor %}
```